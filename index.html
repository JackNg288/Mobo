<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Stock Trade Ideas</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Chart.js CDN for better charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .container {
            max-width: 1280px;
            margin: auto;
            padding: 1.5rem;
        }
        .trade-idea-card {
            border: 1px solid #2d3748;
        }
        .buy {
            background-color: #059669;
        }
        .sell {
            background-color: #ef4444;
        }
        .hold {
            background-color: #f59e0b;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 0, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #8e58a2;
            width: 2rem;
            height: 2rem;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-950 text-gray-200 min-h-screen">

    <!-- Main Container -->
    <div class="container bg-gray-900 rounded-2xl shadow-2xl overflow-hidden my-8">
        
        <!-- Header Section -->
        <header class="p-8 text-center border-b border-gray-800">
            <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-teal-400 to-blue-500 mb-2">
                AI-Powered Stock Trade Ideas
            </h1>
            <p class="text-lg text-gray-400 max-w-2xl mx-auto">
                Enter a stock ticker to get a sentiment-based AI signal, live price, and historical chart.
            </p>
        </header>

        <!-- Ticker Input and Fetch Button -->
        <section class="p-8 flex flex-col sm:flex-row justify-center items-center gap-4 border-b border-gray-800">
            <input type="text" id="ticker-input" placeholder="e.g., AAPL" class="bg-gray-800 text-gray-200 placeholder-gray-500 px-4 py-2 rounded-full w-full sm:w-64 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button id="fetch-button" class="px-6 py-2 rounded-full font-bold transition-all duration-300 transform hover:scale-105 bg-blue-600 text-white hover:bg-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900 flex items-center gap-2 mt-4 sm:mt-0">
                <span id="button-text">Get AI Signal</span>
                <div id="loading-spinner" class="loading-spinner hidden"></div>
            </button>
        </section>

        <!-- Trade Ideas Display Area -->
        <main id="trade-ideas-container" class="p-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
             <div class="col-span-full flex justify-center items-center text-gray-400">
                <p>Enter a stock ticker and click "Get AI Signal" to see the latest trade ideas.</p>
             </div>
        </main>

    </div>

    <!-- JavaScript for dynamic content and API calls -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('trade-ideas-container');
            const fetchButton = document.getElementById('fetch-button');
            const buttonText = document.getElementById('button-text');
            const loadingSpinner = document.getElementById('loading-spinner');
            const tickerInput = document.getElementById('ticker-input');

            // API keys from the user. NOTE: This should be on a backend server in production.
            const POLYGON_API_KEY = 'M426cmntnrT73IDYiKyu_E7TKyLfoSy1';
            const FINNHUB_API_KEY = 'd39nm2hr01qoho9gl3ogd39nm2hr01qoho9gl3p0';
            
            // Simplified financial sentiment keywords for a basic AI analysis
            const positiveWords = ['increase', 'gain', 'growth', 'rise', 'strong', 'positive', 'win', 'acquire', 'launch', 'expand', 'profit', 'surpass', 'success', 'outperform', 'upgrade', 'rally', 'breakthrough', 'record', 'soar', 'expand'];
            const negativeWords = ['decline', 'loss', 'drop', 'fall', 'weak', 'negative', 'miss', 'slump', 'downsize', 'decrease', 'sell-off', 'fail', 'warning', 'undervalued', 'downgrade', 'plunge', 'crisis', 'recession', 'headwinds'];

            // Function to analyze sentiment based on keywords
            function getSentiment(text) {
                let score = 0;
                const lowerText = text.toLowerCase();
                positiveWords.forEach(word => {
                    if (lowerText.includes(word)) score++;
                });
                negativeWords.forEach(word => {
                    if (lowerText.includes(word)) score--;
                });
                return score;
            }

            // Function to calculate Simple Moving Average (SMA)
            function calculateSMA(data, period) {
                const sma = [];
                for (let i = 0; i <= data.length - period; i++) {
                    const slice = data.slice(i, i + period);
                    const sum = slice.reduce((acc, curr) => acc + curr.c, 0);
                    sma.push({ t: slice[slice.length - 1].t, c: sum / period });
                }
                return sma;
            }

            // Function to get a combined signal from technical and sentiment analysis
            function getCombinedSignal(sentimentScore, shortSMA, longSMA) {
                const recentShort = shortSMA[shortSMA.length - 1]?.c;
                const recentLong = longSMA[longSMA.length - 1]?.c;
                const previousShort = shortSMA[shortSMA.length - 2]?.c;
                const previousLong = longSMA[longSMA.length - 2]?.c;

                let technicalSignal = 'Hold';
                let technicalReason = 'No clear technical signal.';

                if (recentShort > recentLong && previousShort < previousLong) {
                    technicalSignal = 'Buy'; // Golden Cross
                    technicalReason = 'The short-term moving average has crossed above the long-term moving average.';
                } else if (recentShort < recentLong && previousShort > previousLong) {
                    technicalSignal = 'Sell'; // Death Cross
                    technicalReason = 'The short-term moving average has crossed below the long-term moving average.';
                }

                let finalSignal = 'Hold';
                let finalReason = `Based on news sentiment and technical indicators: ${technicalReason}`;

                if (sentimentScore > 0 && technicalSignal === 'Buy') {
                    finalSignal = 'Buy';
                    finalReason = `Strong positive news sentiment and a technical Buy signal (Golden Cross).`;
                } else if (sentimentScore < 0 && technicalSignal === 'Sell') {
                    finalSignal = 'Sell';
                    finalReason = `Strong negative news sentiment and a technical Sell signal (Death Cross).`;
                } else {
                    finalSignal = 'Hold';
                    if (sentimentScore > 0) finalReason = `Positive news, but no clear technical signal.`;
                    if (sentimentScore < 0) finalReason = `Negative news, but no clear technical signal.`;
                    if (technicalSignal === 'Buy') finalReason = `Technical Buy signal, but news sentiment is mixed.`;
                    if (technicalSignal === 'Sell') finalReason = `Technical Sell signal, but news sentiment is mixed.`;
                }
                
                return { signal: finalSignal, reason: finalReason };
            }

            // Function to generate the HTML for a single trade idea card
            function createTradeIdeaCard(ticker, signal, reason, articles, currentPrice, apiSource) {
                let signalClass;
                if (signal === 'Buy') {
                    signalClass = 'buy';
                } else if (signal === 'Sell') {
                    signalClass = 'sell';
                } else {
                    signalClass = 'hold';
                }
                
                let sentimentMessage = "";
                if (articles.length === 0) {
                    sentimentMessage = "No recent news found for this ticker to perform an analysis.";
                } else {
                    sentimentMessage = `Analysis based on ${articles.length} recent news articles:`;
                }

                let newsListHtml = '';
                if (articles.length > 0) {
                    newsListHtml = `<ul class="list-disc list-inside mt-4 text-sm text-gray-400 max-h-48 overflow-y-auto">`;
                    articles.forEach(article => {
                        newsListHtml += `<li><a href="${article.article_url || article.url}" target="_blank" class="text-blue-400 hover:underline">${article.title || article.headline}</a> (Source: ${article.publisher?.name || article.source})</li>`;
                    });
                    newsListHtml += `</ul>`;
                }
                
                const chartId = `chart-${ticker}-${Date.now()}`;

                return `
                    <div class="trade-idea-card bg-gray-800 rounded-xl p-6 shadow-lg transition-transform duration-300 transform hover:scale-105 col-span-full">
                        <div class="flex items-center justify-between mb-4">
                            <div class="flex items-center">
                                <div class="w-12 h-12 rounded-full ${signalClass} flex items-center justify-center text-white font-bold text-lg">
                                    ${ticker.charAt(0).toUpperCase()}
                                </div>
                                <div class="ml-4">
                                    <h3 class="text-xl font-bold text-gray-100">${ticker.toUpperCase()}</h3>
                                    <p class="text-sm text-gray-400">Current Price: <span class="text-white font-semibold">$${currentPrice.toFixed(2)}</span></p>
                                </div>
                            </div>
                            <span class="text-lg font-semibold px-4 py-1 rounded-full text-white ${signalClass}">${signal}</span>
                        </div>
                        <div class="mb-6">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-xs text-gray-500">Data provided by ${apiSource}</span>
                                <div class="flex gap-2">
                                    <button class="chart-filter px-3 py-1 text-xs rounded-full bg-gray-700 hover:bg-teal-500 hover:text-white" data-horizon="1M">1M</button>
                                    <button class="chart-filter px-3 py-1 text-xs rounded-full bg-gray-700 hover:bg-teal-500 hover:text-white" data-horizon="3M">3M</button>
                                    <button class="chart-filter px-3 py-1 text-xs rounded-full bg-gray-700 hover:bg-teal-500 hover:text-white" data-horizon="1Y">1Y</button>
                                </div>
                            </div>
                            <div class="relative w-full h-72">
                                <canvas id="${chartId}" class="w-full h-full rounded-lg border border-gray-700"></canvas>
                            </div>
                        </div>
                        <p class="text-gray-400 text-sm leading-relaxed"><strong>AI Analysis:</strong> ${reason}</p>
                        <div class="mt-4">
                            <h4 class="font-semibold text-gray-200">${sentimentMessage}</h4>
                            ${newsListHtml}
                        </div>
                    </div>
                `;
            }

            // Function to draw a line chart using Chart.js
            let myChart = null;
            function drawChart(canvasId, data, smas) {
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                
                if (myChart) {
                    myChart.destroy();
                }

                if (data.length === 0) {
                    return;
                }

                const dates = data.map(d => new Date(d.t).toLocaleDateString());
                const prices = data.map(d => d.c);

                // Prepare SMA data for Chart.js
                const sma20_prices = data.map(d => {
                    const sma_point = smas.sma20.find(s => s.t === d.t);
                    return sma_point ? sma_point.c : null;
                });
                const sma50_prices = data.map(d => {
                    const sma_point = smas.sma50.find(s => s.t === d.t);
                    return sma_point ? sma_point.c : null;
                });


                myChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Price',
                            data: prices,
                            borderColor: '#4299e1',
                            backgroundColor: 'rgba(66, 153, 225, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 0,
                            pointHoverRadius: 5,
                        },
                        {
                            label: '20-Day SMA',
                            data: sma20_prices,
                            borderColor: '#10b981', // Green
                            borderWidth: 2,
                            pointRadius: 0,
                            borderDash: [5, 5],
                            fill: false,
                        },
                        {
                            label: '50-Day SMA',
                            data: sma50_prices,
                            borderColor: '#f59e0b', // Yellow
                            borderWidth: 2,
                            pointRadius: 0,
                            borderDash: [5, 5],
                            fill: false,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#e2e8f0',
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: (context) => {
                                        return new Date(data[context[0].dataIndex].t).toLocaleDateString();
                                    },
                                    label: (context) => {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += `$${context.parsed.y.toFixed(2)}`;
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'category',
                                ticks: {
                                    autoSkip: true,
                                    maxTicksLimit: 10,
                                    color: '#6b7280',
                                },
                                grid: {
                                    color: '#2d3748',
                                }
                            },
                            y: {
                                beginAtZero: false,
                                ticks: {
                                    color: '#6b7280',
                                    callback: (value) => `$${value.toFixed(2)}`
                                },
                                grid: {
                                    color: '#2d3748',
                                }
                            }
                        }
                    }
                });
            }

            async function fetchWithFailover(polygonUrl, finnhubUrl) {
                try {
                    const polygonResponse = await fetch(polygonUrl);
                    if (polygonResponse.ok) {
                        return { data: await polygonResponse.json(), source: 'Polygon.io' };
                    }
                    if (polygonResponse.status === 429) {
                        console.warn("Polygon.io API rate limit exceeded. Falling back to Finnhub.");
                        const finnhubResponse = await fetch(finnhubUrl);
                        if (!finnhubResponse.ok) {
                           throw new Error(`Finnhub API Error: Status ${finnhubResponse.status} - ${finnhubResponse.statusText}`);
                        }
                        return { data: await finnhubResponse.json(), source: 'Finnhub.io' };
                    }
                    throw new Error(`Polygon.io API Error: Status ${polygonResponse.status} - ${polygonResponse.statusText}`);
                } catch (error) {
                    console.error("Primary API failed, trying fallback:", error);
                    try {
                        const finnhubResponse = await fetch(finnhubUrl);
                        if (!finnhubResponse.ok) {
                           throw new Error(`Finnhub API Error: Status ${finnhubResponse.status} - ${finnhubResponse.statusText}`);
                        }
                        return { data: await finnhubResponse.json(), source: 'Finnhub.io' };
                    } catch (finnhubError) {
                        throw new Error(`All APIs failed. Please try again later. Details: ${finnhubError.message}`);
                    }
                }
            }


            // Main function to fetch and analyze signals
            async function fetchSignals() {
                const ticker = tickerInput.value.toUpperCase();
                if (!ticker) {
                    container.innerHTML = `<p class="text-center text-red-400 col-span-full">Please enter a stock ticker to get a signal.</p>`;
                    return;
                }

                buttonText.classList.add('hidden');
                loadingSpinner.classList.remove('hidden');
                fetchButton.disabled = true;
                container.innerHTML = `<div class="col-span-full flex justify-center items-center text-gray-400">
                                          <p>Fetching and analyzing data for ${ticker}...</p>
                                       </div>`;

                try {
                    const today = new Date();
                    const fromDate = new Date();
                    fromDate.setFullYear(today.getFullYear() - 1);
                    const fromFormatted = `${fromDate.getFullYear()}-${String(fromDate.getMonth() + 1).padStart(2, '0')}-${String(fromDate.getDate()).padStart(2, '0')}`;
                    const toFormatted = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

                    // URLs for both APIs
                    const polygonChartApiUrl = `https://api.polygon.io/v2/aggs/ticker/${ticker}/range/1/day/${fromFormatted}/${toFormatted}?adjusted=true&sort=asc&apiKey=${POLYGON_API_KEY}`;
                    const finnhubChartApiUrl = `https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&from=${Math.floor(fromDate.getTime() / 1000)}&to=${Math.floor(today.getTime() / 1000)}&token=${FINNHUB_API_KEY}`;
                    
                    const polygonNewsApiUrl = `https://api.polygon.io/v2/reference/news?ticker=${ticker}&published_utc.gte=${fromFormatted}&limit=50&apiKey=${POLYGON_API_KEY}`;
                    const finnhubNewsApiUrl = `https://finnhub.io/api/v1/company-news?symbol=${ticker}&from=${fromFormatted}&to=${toFormatted}&token=${FINNHUB_API_KEY}`;

                    const polygonQuoteApiUrl = `https://api.polygon.io/v2/aggs/ticker/${ticker}/prev?adjusted=true&apiKey=${POLYGON_API_KEY}`;
                    const finnhubQuoteApiUrl = `https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${FINNHUB_API_KEY}`;

                    // Fetch data using the failover mechanism
                    const chartResult = await fetchWithFailover(polygonChartApiUrl, finnhubChartApiUrl);
                    const newsResult = await fetchWithFailover(polygonNewsApiUrl, finnhubNewsApiUrl);
                    const quoteResult = await fetchWithFailover(polygonQuoteApiUrl, finnhubQuoteApiUrl);

                    // Process chart data from either API
                    let historicalPrices = [];
                    if (chartResult.source === 'Polygon.io') {
                        historicalPrices = chartResult.data.results || [];
                    } else { // Finnhub
                        // Correctly handle Finnhub's array-based data format
                        historicalPrices = (chartResult.data.c || []).map((close, index) => ({
                            t: (chartResult.data.t[index] || 0) * 1000,
                            c: close,
                        }));
                    }
                    
                    const currentPrice = quoteResult.source === 'Polygon.io' ? quoteResult.data.results[0].c : quoteResult.data.c;
                    
                    // Process news data from either API
                    let sentimentScore = 0;
                    let newsArticles = [];
                    if (newsResult.source === 'Polygon.io') {
                        newsArticles = newsResult.data.results || [];
                        newsArticles.forEach(article => {
                            sentimentScore += getSentiment(article.title);
                            if (article.description) sentimentScore += getSentiment(article.description);
                        });
                    } else { // Finnhub
                        newsArticles = newsResult.data || [];
                        newsArticles.forEach(article => {
                            sentimentScore += getSentiment(article.headline);
                            if (article.summary) sentimentScore += getSentiment(article.summary);
                        });
                    }
                    
                    // Calculate SMAs for technical analysis
                    const sma20 = calculateSMA(historicalPrices, 20);
                    const sma50 = calculateSMA(historicalPrices, 50);

                    // Get the combined signal
                    const combinedSignal = getCombinedSignal(sentimentScore, sma20, sma50);

                    const chartCanvasId = `chart-${ticker}-${Date.now()}`;
                    container.innerHTML = createTradeIdeaCard(ticker, combinedSignal.signal, combinedSignal.reason, newsArticles, currentPrice, chartResult.source);
                    
                    // Add chart event listeners
                    const chartFilters = document.querySelectorAll('.chart-filter');
                    chartFilters.forEach(button => {
                        button.addEventListener('click', async (e) => {
                            const horizon = e.target.dataset.horizon;
                            await updateChart(ticker, horizon, chartCanvasId);
                        });
                    });

                    // Initial chart render (default to 1Y)
                    drawChart(chartCanvasId, historicalPrices, { sma20, sma50 });

                } catch (error) {
                    console.error("Failed to fetch data:", error);
                    container.innerHTML = `<p class="text-center text-gray-500 col-span-full">Error fetching data. This may be due to an invalid ticker or an API issue. Check the console for more details.</p>`;
                } finally {
                    buttonText.classList.remove('hidden');
                    loadingSpinner.classList.add('hidden');
                    fetchButton.disabled = false;
                }
            }

            // Function to update the chart for a new time horizon
            async function updateChart(ticker, horizon, chartCanvasId) {
                const today = new Date();
                let fromDate = new Date();
                if (horizon === '1M') {
                    fromDate.setMonth(today.getMonth() - 1);
                } else if (horizon === '3M') {
                    fromDate.setMonth(today.getMonth() - 3);
                } else if (horizon === '1Y') {
                    fromDate.setFullYear(today.getFullYear() - 1);
                }
                
                const fromFormatted = `${fromDate.getFullYear()}-${String(fromDate.getMonth() + 1).padStart(2, '0')}-${String(fromDate.getDate()).padStart(2, '0')}`;
                const toFormatted = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

                const polygonChartApiUrl = `https://api.polygon.io/v2/aggs/ticker/${ticker}/range/1/day/${fromFormatted}/${toFormatted}?adjusted=true&sort=asc&apiKey=${POLYGON_API_KEY}`;
                const finnhubChartApiUrl = `https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&from=${Math.floor(fromDate.getTime() / 1000)}&to=${Math.floor(today.getTime() / 1000)}&token=${FINNHUB_API_KEY}`;
                
                try {
                    const chartResult = await fetchWithFailover(polygonChartApiUrl, finnhubChartApiUrl);

                    let historicalPrices = [];
                    if (chartResult.source === 'Polygon.io') {
                        historicalPrices = chartResult.data.results || [];
                    } else { // Finnhub
                        historicalPrices = (chartResult.data.c || []).map((close, index) => ({
                            t: (chartResult.data.t[index] || 0) * 1000,
                            c: close,
                        }));
                    }

                    const sma20 = calculateSMA(historicalPrices, 20);
                    const sma50 = calculateSMA(historicalPrices, 50);

                    const chartCanvas = document.getElementById(chartCanvasId);
                    if (chartCanvas) {
                        drawChart(chartCanvas.id, historicalPrices, { sma20, sma50 });
                    }

                } catch (error) {
                    console.error("Failed to update chart:", error);
                    // You could add an error message to the UI here if needed
                }
            }

            // Event listener for the fetch button
            fetchButton.addEventListener('click', fetchSignals);

            // Allow hitting Enter in the input field
            tickerInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    fetchSignals();
                }
            });
        });
    </script>

</body>
</html>
